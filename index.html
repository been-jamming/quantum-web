<!DOCTYPE html>
<html>
<head>
<title>Test</title>
<style>
canvas {
	width: 80%;
	height: 80%;
	padding: 0px;
	position: absolute;
	top: 0px;
	left: 0px;
}

body {
	margin: 0px;
}
</style>
<script src="math.js" type="text/javascript"></script>
</head>

<body>
<canvas class="wavefunction"></canvas>

<script>
	context = document.getElementsByClassName("wavefunction")[0].getContext("2d");
	context.canvas.width = window.innerWidth*0.8;
	context.canvas.height = window.innerHeight*0.8;
	context.fillStyle = "black";
	context.fillRect(0, 0, context.canvas.width, context.canvas.height);

	width = context.canvas.width;
	height = context.canvas.height;

	resolution = 3;

	mass = 1;

	function mod(a, b){
		return (a%b + b)%b;
	}

	function complex_to_color(val){
		var red;
		var green;
		var blue;
		var angle;

		angle = mod(math.atan2(math.re(val), math.im(val)), 2*Math.PI);

		if(angle <= Math.PI/3 || angle >= 5*Math.PI/3){
			red = 1;
			if(angle <= Math.PI/3){
				green = angle*3/Math.PI;
				blue = 0;
			} else {
				green = 0;
				blue = 1 - (angle - 5*Math.PI/3)*3/Math.PI;
			}
		} else if(angle >= Math.PI/3 && angle <= Math.PI){
			green = 1;
			if(angle <= 2*Math.PI/3){
				red = (2*Math.PI/3 - angle)*3/Math.PI;
				blue = 0;
			} else {
				red = 0;
				blue = 1 - (Math.PI - angle)*3/Math.PI;
			}
		} else if(angle >= Math.PI && angle <= 5*Math.PI/3){
			blue = 1;
			if(angle <= 4*Math.PI/3){
				red = 0;
				green = (4*Math.PI/3 - angle)*3/Math.PI;
			} else {
				red = 1 - (5*Math.PI/3 - angle)*3/Math.PI;
				green = 0;
			}
		}

		return {red: red, green: green, blue: blue};
	}

	function draw_graph(vals){
		context.fillStyle = "black";
		context.fillRect(0, 0, width, height);
		for(var i = 0; i < resolution; i++){
			var color = complex_to_color(vals[i]);
			var len = math.abs(vals[i]);
			len = len*len;
			context.fillStyle = "rgb("+255*color.red+","+255*color.green+","+255*color.blue+")";
			context.fillRect(width*i/resolution, height*(1 - len), width/resolution, height*len);
		}
	}

	function inverse_fourier(){
		var output = Array(resolution);
		for(var i = 0; i < resolution; i++){
			output[i] = Array(resolution);
			for(var j = 0; j < resolution; j++){
				var momentum = j - (resolution - 1)/2;
				output[i][j] = math.multiply(1.0/math.sqrt(resolution), math.exp(math.multiply(2, math.pi, math.complex("i"), i, momentum, 1.0/resolution)));
			}
		}
		return output;
	}

	function momentum_operator(ft, ift){
		var diag = [];
		for(var i = 0; i < resolution; i++){
			var momentum = i - (resolution - 1)/2;
			diag[i] = 2*math.pi*momentum/resolution;
		}
		return math.multiply(ift, math.diag(diag), ft);
	}

	function hamiltonian(P){
		return math.multiply(P, P, 1.0/(2*mass));
	}

	ift = inverse_fourier();

	ft = math.inv(ift);

	P = momentum_operator(ft, ift);
	H = hamiltonian(P);

	eigs = math.eigs(H);
	
	state = [];

	for(var i = 0; i < resolution; i++){
		//state[i] = math.complex(math.cos(1*i*2*math.pi/resolution), math.sin(1*i*2*math.pi/resolution));
		//state[i] = math.complex(Math.random(), Math.random());
		state[i] = math.multiply(1/((math.abs(i - resolution/3) + 1)*(math.abs(i - resolution/3) + 1)), math.exp(math.multiply(math.complex("i"), 2*2*math.pi*i/resolution)))
	}
	state = math.multiply(ft, state);
	state = normalize(state);

	state = eigs.vectors[0];

	//Logging the inner products between eigenvectors and the state
	//will allow us to correct the state later
	inner_products = math.multiply(math.ctranspose(eigs.vectors), state);

	function correct_state(state, inner_products, time){
		var z;

		for(i = 0; i < eigs.vectors.length; i++){
			z = math.subtract(inner_products[i], math.multiply(math.exp(math.multiply(math.complex(0, 1), eigs.values[i], time)), math.dot(eigs.vectors[i], state)));
			state = math.add(state, math.multiply(z, eigs.vectors[i]));
		}
		
		return state;
	}

	function normalize(state){
		return math.divide(state, math.sqrt(math.dot(state, state)));
	}

	function timestep(state, H, dt, time){
		var change = math.multiply(math.complex("-i"), dt, math.multiply(H, state));
		state = math.add(state, change);
		//state = correct_state(state, inner_products, time + dt);

		return normalize(state);
	}


	time = 0;

	function tick(){
		for(i = 0; i < 10; i++){
			state = timestep(state, H, 0.01, time);
			time += 0.01;
		}
		draw_graph(state);
		//draw_graph(math.multiply(ft, state));
	}

	setInterval(tick, 50);
</script>
</body>
</html>
